<!DOCTYPE html>
<html>
<head>
<title>BadIDE</title>
<style>
/*
* {
  font: 16px monospace;
}
*/
#header {
  font-size: xx-large;
  font-style: oblique;
}
button {
  border: 2px outset #ddd;
  border-style: outset;
  background-color: #eee;
}
button:hover {
  background-color: #ddd;
}
button.active {
  background-color: #ccc;
  border-style: inset;
}
input {
  /* font: inherit; */
  font: 100% monospace;
  vertical-align: baseline;
}
/*
button {
  font: inherit;
}
*/
select {
  font: inherit;
}

/* Layout */
html, body { margin: 0; padding: 0; }
body { text-align: center; }
#container {
  /*
  width: max-content;
  */
  /*
  grid-template:
    "simulator editor cart" auto
    "memory editor cart" 1fr
    / repeat(3, auto);
  */
  display: inline-grid;
  gap: 1rem;
  grid-template-areas: "sim ed cart" "mem ed cart";
  grid-template-columns: repeat(3, auto);
  grid-template-rows: auto 1fr;
  justify-items: center;
  padding: 1rem;
}
#simulator-panel { grid-area: sim; }
#editor-panel { grid-area: ed; }
#mem-panel { grid-area: mem; }
#cart-panel { grid-area: cart; }
/*
#cart-panel .toolbar {
  display: grid;
  grid-template-columns: repeat(5, auto) 1fr;
}
*/
.panel {
  display: flex;
  /*
  align-items: center;
  */
  flex-direction: column;
  gap: 10px;
}
.toolbar {
  /* display: flex; */
}
#editor {
  height: 100%;
  font-size: large;
  /*
  box-sizing: border-box;
  */
}
#display {
  height: 200px;
  width: 180px;
}
#keypad {
  display: grid;
  grid-template-columns: repeat(6, 1fr);
  grid-template-rows: repeat(4, 1fr);
  height: 200px;
  width: 300px;
}
.monitor {
  display: grid;
  font-family: monospace;
}
#mem-monitor {
  grid-template-columns: repeat(16, 1fr);
}
#mem-monitor span:hover {
  background-color: #3dd;
}
#cart-monitor {
  grid-template-columns: repeat(16, auto);
}
#cart-monitor span:hover {
  background-color: #3dd;
}
#cart-monitor span span:hover {
  background-color: #4ff;
}
#cart-panel .toolbar button {
  float: right;
}

/* Colour */
body { background-color: #ddd; }
#keypad { background-color: #aff; }
#display { background-color: #aaf; }
#container { background-color: #afa; }
.panel:nth-child(1) { background-color: #faf; }
.panel:nth-child(2) { background-color: #ffa; }
.panel:nth-child(3) { background-color: #faa; }
.panel:nth-child(4) { background-color: #aff; }

#keypad :nth-child( 1) { grid-row: 4; grid-column: 2; }
#keypad :nth-child( 2) { grid-row: 1; grid-column: 1; }
#keypad :nth-child( 3) { grid-row: 1; grid-column: 2; }
#keypad :nth-child( 4) { grid-row: 1; grid-column: 3; }
#keypad :nth-child( 5) { grid-row: 2; grid-column: 1; }
#keypad :nth-child( 6) { grid-row: 2; grid-column: 2; }
#keypad :nth-child( 7) { grid-row: 2; grid-column: 3; }
#keypad :nth-child( 8) { grid-row: 3; grid-column: 1; }
#keypad :nth-child( 9) { grid-row: 3; grid-column: 2; }
#keypad :nth-child(10) { grid-row: 3; grid-column: 3; }
#keypad :nth-child(11) { grid-row: 3; grid-column: 5; }
#keypad :nth-child(12) { grid-row: 2; grid-column: 6; }
</style>
</head>
<body>
<div id="container">
  <div id="simulator-panel" class="panel">
    <div id="header">BadIDE</div>
    <div class="toolbar">
      <button id="reset" onclick="reset()">Reset</button>
      <button id="run">Run</button>
      <button id="step">Step</button>
    </div>
    <div class="message-area"></div>
    <canvas id="display" height="200" width="180"></canvas>
    <div id="keypad">
      <button>0</button>
      <button>1</button>
      <button>2 ↑</button>
      <button>3</button>
      <button>4 ←</button>
      <button>5</button>
      <button>→ 6</button>
      <button>7</button>
      <button>8 ↓</button>
      <button>9</button>
      <button>A</button>
      <button>B</button>
    </div>
  </div>
  <div id="editor-panel" class="panel">
    <div class="toolbar">
      <input></input>
      <select>
        <option>Snake</option>
        <option>Tetris</option>
      </select>
      <button id="save">Save</button>
      <button id="open">Open</button>
      <button id="compile" onclick="compile()">Compile</button>
    </div>
    <div class="message-area"></div>
    <textarea id="editor" cols="65" spellcheck="false">
    </textarea>
  </div>
  <div id="cart-panel" class="panel">
    <div class=toolbar>
      <input id="cart-word-addr" size="4" readonly>
      <input id="cart-word-value" size="6" readonly>
      <input id="cart-byte-addr" size="4" readonly>
      <input id="cart-byte-value" size="3" readonly>
      <input id="cart-byte-inst" size="6" readonly>
      <button id="save">Save</button>
      <button id="open">Open</button>
    </div>
    <div id="cart-monitor" class="monitor">
    </div>
  </div>
  <div id="mem-panel" class="panel">
    <div class=toolbar>
      Dec: <input id="" size="10" value="123" readonly>
      <input id="" value="bar" readonly>
    </div>
    <div id="mem-monitor" class="monitor">
    </div>
  </div>
</div>
<script>
const prec = [
  [ -1, -1, -1, -1, 0,  0,  0, 0,  0,  0, -1, -1, -1, -1, -1, -1],
  [ -1, -1, -1, -1, 0,  0,  0, 0,  0,  0, -1, -1, -1, -1, -1, -1],
  [ -1, -1, -1, -1, 0,  0,  0, 0,  0,  0, -1, -1, -1, -1, -1, -1],
  [ -1, -1, -1, -1, 0,  0,  0, 0,  0,  0, -1, -1, -1, -1, -1, -1],
  [  0,  0,  0,  0, 0,  0,  0, 0,  0,  0,  0,  0,  0,  0,  0,  0],
  [  0,  0,  0,  0, 0, -1, -1, 0,  0,  0,  0,  0,  0,  0,  0,  0],
  [  0,  0,  0,  0, 0, +1, -1, 0,  0,  0,  0,  0,  0,  0,  0,  0],
  [  0,  0,  0,  0, 0,  0,  0, 0,  0,  0,  0,  0,  0,  0,  0,  0],
  [  0,  0,  0,  0, 0,  0,  0, 0, -1, -1,  0,  0,  0,  0,  0,  0],
  [  0,  0,  0,  0, 0,  0,  0, 0, -1, -1,  0,  0,  0,  0,  0,  0],
  [ +1, +1, +1, +1, 0,  0,  0, 0,  0,  0,  0,  0,  0,  0,  0,  0],
  [ +1, +1, +1, +1, 0,  0,  0, 0,  0,  0,  0,  0,  0,  0,  0,  0],
  [ +1, +1, +1, +1, 0,  0,  0, 0,  0,  0,  0,  0,  0,  0,  0,  0],
  [ +1, +1, +1, +1, 0,  0,  0, 0,  0,  0,  0,  0,  0,  0,  0,  0],
  [ +1, +1, +1, +1, 0,  0,  0, 0,  0,  0,  0,  0,  0,  0,  0,  0],
  [ +1, +1, +1, +1, 0,  0,  0, 0,  0,  0,  0,  0,  0,  0,  0,  0],
]
class Gtfo extends Error {}
function gtfo() { throw new Gtfo() }

/* Widgets */
const display = document.getElementById('display')
const ed   = document.getElementById('editor')
const kp   = document.getElementById('keypad')
let cartMon = document.getElementById('cart-monitor')
let memMon = document.getElementById('mem-monitor')

let memArray = new ArrayBuffer(1024)
let cartArray = new ArrayBuffer(2048)
let code = new Uint8Array(cartArray)
let cart = new Int16Array(cartArray)
let mem = new Int16Array(memArray)

/* Display */
function updateDisplay() {
  const context = display.getContext('2d')
  const palette = ['#200', '#400', '#900', '#d00']
  for (let i = 0; i < 10; i++) {
    for (let j = 0; j < 9; j++) {
      context.fillStyle = palette[frameBuffer[i][j]]
      context.fillRect(20 * i, 20 * j, 20, 20)
    }
  }
}

/* Memory */
function initMemMon() {
  for (let i = 0; i < 512; i++) {
    memMon.appendChild(document.createElement('span'))
  }
}
function updateMemMon() {
  for (let i = 0; i < 512; i++) {
    memMon.children[i].innerHTML =
      mem[i].toString(16).padStart(4, '0')
  }
}

/* Cart */
function initCart() {
  for (let i = 0; i < 1024; i++) {
    cartMon.appendChild(document.createElement('span'))
    for (let j = 0; j < 2; j++) {
      cartMon.children[i].appendChild(
        document.createElement('span')
      )
    }
  }
}
function updateCart() {
  for (let i = 0; i < 1024; i++) {
    for (let j = 0; j < 2; j++) {
      cartMon.children[i].children[j].innerHTML =
        code[2 * i + j].toString(16).padStart(2, '0')
    }
  }
}

function nodeIndex(n) {
  return Array.from(n.parentNode.children).indexOf(n)
}
cartMon.addEventListener('mouseover', (e) => {
  const i = nodeIndex(e.target.parentNode)
  const j = nodeIndex(e.target)
  document.getElementById('cart-word-addr').value = i
  document.getElementById('cart-word-value').value = cart[i]
  document.getElementById('cart-byte-addr').value = 2 * i + j
  document.getElementById('cart-byte-value').value = code[2 * i + j]
  let [m, v] = decode(code[2 * i + j])
  if (v) {
    document.getElementById('cart-byte-inst').value = m + ' ' + v
  } else {
    document.getElementById('cart-byte-inst').value = m
  }
})

/* Keypad */
function press(i) {
  console.log(i + " pressed")
  kp.children[i].classList.add('active')
}
function release(i) {
  console.log(i + " released")
  kp.children[i].classList.remove('active')
}
for (let i = 0; i < 12; i++) {
  let n = kp.children[i]
  n.addEventListener('mousedown', () => { press(i) })
  n.addEventListener('mouseup', () => { release(i) })
}
document.addEventListener('keydown', (e) => {
  if (e.repeat) return
  if (document.activeElement != ed) {
    switch (e.key) {
    case '1':           press( 1); break
    case '2': case 'w': press( 2); break
    case '3':           press( 3); break
    case '4': case 'a': press( 4); break
    case '5':           press( 5); break
    case '6': case 'd': press( 6); break
    case '7':           press( 7); break
    case '8': case 's': press( 8); break
    case '9':           press( 9); break
    case '0':           press( 0); break
    case '-': case 'j': press(10); break
    case '=': case 'i': press(11); break
    }
  }
})
document.addEventListener('keyup', (e) => {
  if (document.activeElement != ed) {
    switch (e.key) {
    case '1':           release( 1); break
    case '2': case 'w': release( 2); break
    case '3':           release( 3); break
    case '4': case 'a': release( 4); break
    case '5':           release( 5); break
    case '6': case 'd': release( 6); break
    case '7':           release( 7); break
    case '8': case 's': release( 8); break
    case '9':           release( 9); break
    case '0':           release( 0); break
    case '-': case 'j': release(10); break
    case '=': case 'i': release(11); break
    }
  }
})

/* Editor toolbar */
document.addEventListener('keydown', (e) => {
  if (e.ctrlKey) {
    switch (e.key) {
    case 's':     break
    case 'o':     break
    case 'Enter': e.preventDefault(); compile(); break
    }
  }
})

/* Fancy characters */
let editorState = 11
ed.addEventListener('mousedown', () => { editorState = 11 })
ed.addEventListener('keydown', (e) => {
  const input = ['Shift', '%', '*', '-', '/', '<', '=', '>', '\\']
  const plain = ['%', '*', '/=', '<-', '<<', '<=', '>=', '>>', '\\/']
  const fancy = ['÷', '×', '≠', '←', '«', '≤', '≥', '»', '∨']
  const trans = [
    [13,  0, 0, 1, 13, 9, 10, 13, 11, 12],
    [13,  1, 0, 1, 13, 9, 10, 13, 11, 12],
    [13,  2, 0, 1, 13, 9, 10, 13, 11, 12],
    [13,  3, 0, 1, 13, 9, 10, 13, 11, 12],
    [13,  4, 0, 1, 13, 9, 10, 13, 11, 12],
    [13,  5, 0, 1, 13, 9, 10, 13, 11, 12],
    [13,  6, 0, 1, 13, 9, 10, 13, 11, 12],
    [13,  7, 0, 1, 13, 9, 10, 13, 11, 12],
    [13,  8, 0, 1, 13, 9, 10, 13, 11, 12],
    [13,  9, 0, 1, 13, 9, 10,  2, 11, 12],
    [13, 10, 0, 1,  3, 9,  4,  5, 11, 12],
    [13, 11, 0, 1, 13, 9, 10,  6,  7, 12],
    [13, 12, 0, 1, 13, 8, 10, 13, 11, 12],
    [13, 13, 0, 1, 13, 9, 10, 13, 11, 12],
  ]
  const oldState = editorState
  const newState = trans[oldState][input.indexOf(e.key) + 1]
  let nDelete, insertion
  if (e.key == 'Backspace' && oldState < 9) {
    nDelete = 1
    insertion = plain[oldState]
  } else if (newState < 9) {
    nDelete = (newState > 1)
    insertion = fancy[newState]
  }
  if (insertion) {
    e.preventDefault()
    ed.setRangeText(
      insertion,
      ed.selectionStart - nDelete,
      ed.selectionEnd,
    )
    ed.selectionStart += insertion.length
    ed.selectionEnd = ed.selectionStart
  }
  editorState = newState
})

/* Autoindent */
ed.addEventListener('keydown', (e) => {
  if (!e.ctrlKey && e.key == 'Enter') {
    e.preventDefault()
    let n = 0
    loop: for (let i = ed.selectionStart - 1; i >= 0; i--) {
      switch (ed.value[i]) {
      case '\n': break loop
      case ' ': n++; break
      default: n = 0; break
      }
    }
    ed.setRangeText('\n' + ' '.repeat(n))
    ed.selectionStart += 1 + n
    ed.selectionEnd = ed.selectionStart
  }
})

let src = ed.value
let tok = []
let root

const keywords = [
  'arr',
  'var',
  'data',
  'if',
  'elif',
  'else',
  'proc',
  'fun',
  'for',
  'while',
  'end',
  'ret',
  'fun',
  'not',
  'or',
  'and',
]

const unop = '-~'
const binop = '+-×÷|&∨~«»<≤=≥>≠'

function message(m) {
  document.querySelector('#editor-panel .message-area').innerHTML = m
}

function highlightRange(i, j) {
  ed.focus()
  ed.selectionStart = i
  ed.selectionEnd = j
}

function highlightChar(i) {
  highlightRange(i, i + 1)
}

function highlightTok(t) {
  highlightRange(tok[t].start, tok[t].end)
}

function scan() {
  const abc = (
    'ABCDEFGHIJKLMNOPQRSTUVWXYZÅÄÖ' +
    'abcdefghijklmnopqrstuvwxyzåäö'
  )
  let i = 0
  while (i < src.length) {
    if ('\t\n '.includes(src[i])) {
      i++
    } else if (src[i] == ';') {
      do { i++ } while (src[i] != '\n')
    } else {
      tok.push({ start: i })
      let t = tok.length - 1
      if ('0123456789'.includes(src[i])) {
        do { i++ } while ('0123456789'.includes(src[i]))
        tok[t].type = 'num'
        tok[t].val = Number(src.substring(tok[t].start, i))
      } else if (abc.includes(src[i])) {
        do { i++ } while (abc.includes(src[i]))
        let w = src.substring(tok[t].start, i).toLowerCase()
        if (keywords.includes(w)) {
          tok[t].type = w
        } else {
          tok[t].type = 'id'
          tok[t].val = w
        }
      } else if ('+-×÷<≤=≥>≠~|&«»'.includes(src[i])) {
        tok[t].type = 'op'
        tok[t].val = src[i++]
      } else if ('←(),[]'.includes(src[i])) {
        tok[t].type = src[i++]
      } else {
        message('Error: Illegal character')
        highlightChar(i)
        gtfo()
      }
      tok[t].end = i
    }
  }
  tok.push({ type: 'end', start: i, end: i })
}

function parse(ref) {
  let i = 0 /* token index */
  function match(tokType, nodeType) {
    if (tok[i].type == tokType) {
      return {
        type: nodeType ?? tokType,
        val: tok[i].val,
        start: tok[i].start,
        end: tok[i++].end,
        child: [],
      }
    }
  }
  function expect(tokType, nodeType) {
    let u = match(tokType, nodeType)
    if (u) return u
    highlightTok(i)
    message('Error: Expected ' + tokType)
    gtfo()
  }
  function num() {
    return expect('num').val
  }
  function id() {
    return expect('id').val
  }
  function glob(env) {
    console.assert(env.length == 2)
    while (env[1].length == 2) env = env[1]
    return env
  }
  function block(env) {
    let u = {
      type: 'block',
      size: 0,
      dec: [],
      body: [],
    }
    let v, w
    env = [u, env]
    for (;;) {
      if (v = match('var')) {
        v.name = expect('id')
        v.ind = u.size
        v.size = 1
        u.size += v.size
        u.dec.push(v)
        continue
      }
      if (v = match('arr')) {
        v.name = expect('id').val
        expect('[')
        v.shape = list(num, ']')
        v.rank = v.shape.length
        v.stride = Array(v.rank)
        v.ind = u.size
        v.size = 1
        for (let i = v.rank - 1; i >= 0; i--) {
          v.size *= v.shape[i]
          v.stride[i] = v.size
        }
        u.size += v.size
        u.dec.push(v)
        continue
      }
      if (v = match('proc', 'procdec')) {
        v.name = expect('id').val
        v.arg = list(id, ')')
        v.child.push(block([v, glob(env)]))
        expect('end')
        u.dec.push(v)
        continue
      }
      if (v = match('fun', 'fundec')) {
        v.arg = [param()]
        expect('←')
        v.name = expect('id').val
        expect('(')
        v.argv.push(...list(param, ')'))
        v.child.push(block([v, glob(env)]))
        expect('end')
        u.dec.push(v)
        continue
      }
      break
    }
    for (;;) {
      if (v = match('id', 'ref')) {
        ref.push([v, env])
        if (w = match('(', 'proccall')) {
          w.child = [v, ...list(exp, ')', env)]
          u.body.push(v)
          continue
        }
        if (w = match('[', 'ind')) {
          w.body = [v, ...list(exp, ']', env)]
          v = w
        }
        w = expect('←', 'ass')
        w.child = [v, exp(env)]
        u.body.push(w)
        continue
      }
      if (v = match('if')) {
        v.cond = [exp()]
        v.child.push(block(glob))
        while (match('elif')) {
          v.cond.push(exp())
          v.child.push(block(glob))
        }
        if (match('else')) {
          v.child.push(block(glob))
        }
        expect('end')
        u.body.push(v)
        continue
      }
      if (v = match('while')) {
        v.cond = [exp()]
        v.child.push(block(glob))
        expect('end')
        u.body.push(v)
        continue
      }
      if (v = match('for')) {
        v.var = expect('id').val
        v.lim = expect('num').val
        v.child.push(block(glob))
        expect('end')
        u.body.push(v)
        continue
      }
      if (v = match('break')) {
        u.body.push(v)
        continue
      }
      if (v = match('cont')) {
        u.body.push(v)
        continue
      }
      if (v = match('ret')) {
        u.child.push(v)
        continue
      }
      break
    }
    return u
  }
  function exp(env) {
    let tor = [] /* operator stack */
    let and = [] /* operand stack */
    function pop() {
      let u = tor.pop()
      u.child = []
      let v = and.pop()
      if (u.type != 'unop') {
        u.child.push(and.pop())
      }
      u.child.push(v)
      and.push(u)
    }
    function push(u) {
      /* just push unop or ind */
      if (u.type != 'binop') {
        tor.push(u)
        return
      }
      loop: while (tor.length > 0) {
        let v = tor.at(-1)
        if (v.type != 'binop') {
          pop()
          continue
        }
        let i = binop.indexOf(v.val)
        let j = binop.indexOf(u.val)
        switch (prec[i][j]) {
        case -1:
          pop()
          continue
        case  0:
          highlightRange(v.start, u.end)
          message('Error: Ambiguous expression')
          gtfo()
        case +1:
          break loop
        }
      }
      tor.push(u)
    }
    for (;;) {
      let v
      while (v = match('op', 'unop')) {
        if (!'-~'.includes(v.val)) {
          highlightTok(i - 1)
          message('Error: Not prefix operator')
          gtfo()
        }
        push(v)
      }
      if (match('(')) {
        and.push(exp())
        expect(')')
      } else if (v = match('num', 'lit')) {
        and.push(v)
      } else if (v = match('id', 'ref')) {
        and.push(v)
      } else {
        message('Error: Expected (, id, or num')
        highlightTok(i)
        gtfo()
      }
      for (;;) {
        if (v = match('(', 'funcall')) {
          push(v)
          and.push(list(exp, ')'))
          continue
        } else if (v = match('[', 'ind')) {
          push(v)
          and.push(list(exp, ']'))
          continue
        }
        break
      }
      if (!(v = match('op', 'binop'))) break
      push(v)
    }
    while (tor.length > 0) pop()
    return and.pop()
  }
  function list(item, end, env) {
    let l = []
    if (match(end)) return l
    do { l.push(item(env)) } while (match(','))
    expect(end)
    return l
  }
  let u = block([])
  for (let v of u.dec) {
    if (['var', 'arr'].includes(v.type)) {
      v.glob = true
    }
  }
  expect('end')
  root = u
}

const inst = [
  'lli', 'lmi', 'lui',
  'nop', 'jump', 'br', 'call', 'ret', 'allo', 'sys',
  'add', 'sub', 'neg', 'mul',  'div', 'rem',  'eq',  'less',
  'and', 'or',  'not', 'xor',  'shl', 'shr',
  'la',  'lr',  'lc',  'sa',   'sr',  'sc',
]

function decode(c) {
  console.assert(c < 256)
  if (c & 0x3) {
    return [inst[(c & 0x3) - 1], c >> 2]
  } else {
    let o = c >> 3
    return [inst[o + 3 - (o > 6) - 2 * (o > 21)]]
  }
}

function encode(m, v) {
  let i = inst.indexOf(m)
  if (i < 4) {
    console.assert(v < 64)
    return (v << 2) | (i + 1)
  } else {
    return (i - 3 + (i > 9) + 2 * (i > 23)) << 3
  }
}

function resolve([u, env]) {
  for (; env.length == 2; env = env[1]) {
    for (let v of env[0].dec) {
      if (u.val == v.name.val) {
        u.target = v
        return
      }
    }
  }
  highlightRange(u.start, u.end)
  message('Error: undeclared')
  gtfo()
}

function check() {
}

function codegen(rel) {
  let i = 0
  function asdf(u) {
    if (u.type == 'block') {
    }
  }
  function emit(m, v) {
    switch (m) {
    case 'imm':
      console.assert(v >= -32768 && v < 32768)
      code[i++] = encode('lli', v & 0x3f)
      v >>= 6
      if (v == -1 || v == 0) break
      code[i++] = encode('lmi', v & 0x3f)
      v >>= 6
      if (v == -1 || v == 0) break
      code[i++] = encode('lui', v & 0x3f)
      break
    default:
      code[i++] = encode(m)
      break
    }
  }
  function block(u) {
    u.start = i
    emit('imm', u.size)
    emit('allo')
    for (let v of u.body) {
      switch (v.type) {
      case 'ass':
        let w = v.child[0].target
        switch (w.type) {
        case 'var':
          emit('imm', w.ind)
          exp(v.child[1])
          emit('sa')
        }
        break
      case 'if':
        exp(cond[0])
      case 'while':
      case 'for':
      case 'break':
      case 'cont':
      case 'ret':
        /* leave */
      }
    }
    emit('imm', -u.size)
    emit('allo')
    u.end = i
  }
  function exp(u) {
    const unopInst = ['neg', 'not']
    const binopInst = [
      'add',  'sub',  'mul', 'quot', 'rem',
      'and',  'or',   'xor', 'shl',  'shr',
      'less', 'less', 'eq',  'less', 'less', 'eq',
    ]
    const swap = [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0]
    const not  = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1]
    let i
    switch (u.type) {
    case 'lit':
      emit('imm', u.val)
      break
    case 'unop':
      i = unop.indexOf(u.val)
      exp(u.child[0])
      emit(unopInst[i])
      break
    case 'binop':
      i = binop.indexOf(u.val)
      exp(u.child[0 ^ swap[i]])
      exp(u.child[1 ^ swap[i]])
      emit(binopInst[i])
      if (not[i]) emit('not')
      break
    case 'ind':
      break
    case 'fun':
      break
    }
  }
  function addr(u, type) {
    rel.push([i, u, type])
    i += 2
  }
  addr(root, 'start')
  emit('jump')
  block(root)
}

function fixup([i, u, type]) {
  code[i] = encode('lli', u.start & 0x3f)
  code[i + 1] = encode('lmi', u.start >> 6)
}

function compile() {
  try {
    src = ed.value
    tok = []
    ref = []
    rel = []
    scan()
    parse(ref)
    console.dir(root)
    console.dir(ref)
    ref.forEach(resolve)
    check()
    codegen(rel)
    rel.forEach(fixup)
    message('Ok')
    updateCart()
    for (let c of code.slice(0, 10)) {
      console.log(decode(c)[0])
    }
  } catch (e) {
    if (e instanceof Gtfo) return
    throw e
  }
}

/* VM state */
let pc, sp, fp
let bv, pv, hv
let fb = Array.from({ length: 9 })

function reset() {
  bv = pv = hv = 0
  pc = sp = fp = 0
  for (let i = 0; i < 9; i++) fb[i] = 0
  for (let i = 0; i < 1024; i++) mem[i] = 0
  updateMemMon()
  updateDisp()
}

function step() {
}

initMemMon()
initCart()
updateMemMon()
updateCart()
compile()
    </script>
  </body>
</html>
