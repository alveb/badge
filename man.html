<!DOCTYPE html>
<html>
<head>
<title>Manual</title>
<style>
/* Typography */
h1 { font-size: x-large; }
h2 { font-size: large; }
code, pre { font-size: 1rem; }

/* Layout */
html, body { margin: 0; padding: 0; }
body { text-align: center; }
body > div {
  display: inline-grid;
  gap: 1rem;
  grid-template-columns: repeat(3, auto);
  padding: 1rem;
}
.column { text-align: left; width: 35rem; }
.display { text-align: center; }
.display > * { text-align: left; }
.display > pre { display: inline-block; margin: 0; }
#instruction-format {
  border-left: 1px solid;
  border-top: 1px solid;
  display: inline-grid;
  grid-template-columns: repeat(9, 1rem);
}
#instruction-format > div {
  border-bottom: 1px solid;
  border-right: 1px solid;
  text-align: center;
}
#instruction-format :nth-child(11) { grid-column: 2 / span 5; }
#instruction-format :nth-child(13) { grid-column: 8 / span 2; }
#instruction-format :nth-child(15) { grid-column: 2 / span 6; }
#instruction-format :nth-child(16) { grid-column: 8 / span 2; }
#instruction-table {
  column-gap: 1rem;
  display: inline-grid;
  grid-template-columns: repeat(4, auto);
}
#operator-table {
  column-gap: 1rem;
  display: inline-grid;
  grid-template-columns: repeat(2, auto);
}

/* Colour */
.column { background-color: #fff; }
body > div { background-color: #aff; }
.display > pre { background-color: #ffe; }
.meta { color: red; }
</style>
</head>
<body>
<div>
<div class="column">
<h1>Badge Virtual Machine (BadVM)</h1>
<h2>Overview</h2>
<p>BadVM has a 16-bit stack-oriented architecture with an 8-bit
byte code format. It has three control registers: a program
counter (<code>pc</code>), a stack pointer (<code>sp</code>), and
a frame pointer (<code>fp</code>), and two distinct memory
regions: a 2 kB cartridge (cart), and a 1 kB working memory
(memory).</p>

<p>The cart resides in flash memory or on an external storage
device, and contains code, assets, and persistent variables, if
the underlying storage medium supports such. Since BadVM has
16-bit word size but 8-bit instruction size, there are two
different views of the cart: viewed through the data channel it
consists of 1 024 words, while viewed through the code channel it
consists of 2 048 instructions. pc is initialized to zero, and
regarded as pointing to the next instruction; thus the program
begins execution from the first byte of the cart.</p>

<p>The memory resides in SRAM, and is zero initialized, as are sp
and fp. sp is regarded as pointing just beyond the end of the
stack, and the stack grows downwards towards higher addresses, so
the stacks tarts out empty and can potentially span the entire
memory.</p>

<h2>Byte code</h2>
<p>There are two instruction formats, A and B, distinguished by
the two least significant bits of the instruction. Type A are for
loading immediate values; type B is for everything else. (You may
notice that type B instructions have a spare bit. Perfect for
secret messages!)</p>
<div class="display">
<div id="instruction-format">
<div></div>
<div>7</div><div>6</div><div>5</div><div>4</div>
<div>3</div><div>2</div><div>1</div><div>0</div>
<div>A</div><div>opcode</div><div></div><div>ab</div>
<div>B</div><div>imm</div><div>ab</div>
</div>
</div>
<p>Type B instructions are further divided into four
groups depending on the two most significant bits of the
opcode: control flow, arithmetic operations, logic
operations, and loads and stores.</p>
<div class="display">
<div id="instruction-table">
<div>Mnem.</div><div>ab</div><div>opcode</div>
<div>Long name</div>
<div>lli</div><div>01</div><div>n/a</div>
<div>Load lower immediate</div>
<div>lmi</div><div>10</div><div>n/a</div>
<div>Load middle immediate</div>
<div>lui</div><div>11</div><div>n/a</div>
<div>Load upper immediate</div>
<div>nop</div><div>00</div><div>00000</div>
<div>No operation</div>
<div><code>jump</code></div><div>00</div><div>00001</div>
<div>Jump</div>
<div>br</div><div>00</div><div>00010</div>
<div>Branch</div>
<div>call</div><div>00</div><div>00011</div>
<div>Call subroutine</div>
<div>ret</div><div>00</div><div>00100</div>
<div>Return from subroutine</div>
<div>allo</div><div>00</div><div>00101</div>
<div>(De)allocate</div>
<div>sys</div><div>00</div><div>00110</div>
<div>System call</div>
<div>add</div><div>00</div><div>01000</div>
<div>Add</div>
<div>sub</div><div>00</div><div>01001</div>
<div>Subtract</div>
<div>neg</div><div>00</div><div>01010</div>
<div>Negate</div>
<div>mul</div><div>00</div><div>01011</div>
<div>Multiply</div>
<div>div</div><div>00</div><div>01100</div>
<div>Divide</div>
<div>rem</div><div>00</div><div>01101</div>
<div>Reminder</div>
<div>eq</div><div>00</div><div>01110</div>
<div>Equal</div>
<div>less</div><div>00</div><div>01111</div>
<div>Less than</div>
<div>and</div><div>00</div><div>10000</div>
<div>Bitwise and</div>
<div>or</div><div>00</div><div>10001</div>
<div>Bitwise or</div>
<div>not</div><div>00</div><div>10010</div>
<div>Bitwise not</div>
<div>xor</div><div>00</div><div>10011</div>
<div>Bitwise exclusive or</div>
<div>shl</div><div>00</div><div>10100</div>
<div>Shift left logical</div>
<div>shr</div><div>00</div><div>10101</div>
<div>Shift right arithmetic</div>
<div>la</div><div>00</div><div>11000</div>
<div>Load absolute</div>
<div>lr</div><div>00</div><div>11001</div>
<div>Load relative</div>
<div>lc</div><div>00</div><div>11010</div>
<div>Load cart</div>
<div>sa</div><div>00</div><div>11011</div>
<div>Store absolute</div>
<div>sr</div><div>00</div><div>11100</div>
<div>Store relative</div>
<div>sc</div><div>00</div><div>11101</div>
<div>Store cart</div>
</div>
</div>
<p>The semantics of the various instructions is specified by the
following pseudo C code.</p>
<div class="display">
<pre>
nop:  ;
jump: sp -= 1; pc = sp[0];
br:   sp -= 2; if (sp[0]) pc = sp[1];
call: sp -= 1; swap(sp, &pc);
               sp[1] = fp; fp = &sp[1];  sp += 2;
ret:  sp -= 2; fp = sp[1]; pc = sp[0];
allo: sp -= 1; sp += sp[0];
sys:  sp -= 1; sys[sp[0]]();
add:  sp -= 2; sp[0] = sp[0] + sp[1];    sp += 1;
sub:  sp -= 2; sp[0] = sp[0] - sp[1];    sp += 1;
neg:  sp -= 1; sp[0] = -sp[0];           sp += 1;
mul:  sp -= 2; sp[0] = sp[0] * sp[1];    sp += 1;
div:  sp -= 2; sp[0] = sp[0] / sp[1];    sp += 1;
rem:  sp -= 2; sp[0] = sp[0] % sp[1];    sp += 1;
eq:   sp -= 2; sp[0] = (sp[0] == sp[1]); sp += 1;
less: sp -= 2; sp[0] = (sp[0] &lt; sp[1]);  sp += 1;
and:  sp -= 2; sp[0] = sp[0] &amp; sp[1];    sp += 1;
or:   sp -= 2; sp[0] = sp[0] | sp[1];    sp += 1;
not:  sp -= 1; sp[0] = ~sp[0];           sp += 1;
xor:  sp -= 2; sp[0] = sp[0] ^ sp[1];    sp += 1;
shl:  sp -= 2; sp[0] = sp[0] &lt;&lt; sp[1];   sp += 1;
shr:  sp -= 2; sp[0] = sp[0] &gt;&gt; sp[1];   sp += 1;
la:   sp -= 1; sp[0] = *sp[0];           sp += 1;
lr:   sp -= 1; sp[0] = fp[sp[0]];        sp += 1;
lc:   sp -= 1; sp[0] = cart[sp[0]];      sp += 1;
sa:   sp -= 2; *sp[0] = sp[1];
sr:   sp -= 2; fp[sp[0]] = sp[1];
sc:   sp -= 2; cart[sp[0]] = sp[1];
lli:           sp[0][15:0] = imm;        sp += 1;
lmi:  sp -= 1; sp[0][15:6] = imm;        sp += 1;
lui:  sp -= 1; sp[0][15:12] = imm;       sp += 1;
</pre>
</div>
<p>A few notes are in order.</p>
<ul>
<li>pc is incremented unless otherwise specified.</li>
<li>Words should generally be regarded as being signed. This
applies in particular to mul, div, rem, less and shr.</li>
<li>Some operations are undefined. [TBD]</li>
<li>lli, lmi, and lui preform sign extension, which means that
a single lli cover the range [-32, 32), an lli followed by an lmi
cover the range [-2 048, 2 048) (including all addresses), and
finally an lli followed by an lmi followed by an lui cover the
whole range [-65 536, 65 536).</li>
<li>allo and lli are the only instructions which grow the
stack.</li>
</ul>

<h2>Calling convention</h2>
[TBD]

<h2>System functions</h2>
[Order not final.]
<ol start="0">
<li>halt() exits the program.</li>
<li>draw(fb) draws the frame buffer fb on the display. fb is
assumed to be a 10-by-9 array in row-major order, with a 3-bit
colour depth. (If you think that’s a lot of wasted bits, you’d
be right.)</li>
<li>write(b, n, i) scrolls a text of n words from buffer b across
the display. i is a flag indicating whether the message should be
interruptible by a key press.</li>
<li>press() returns a bit vector indicating which keys were
pressed during the previous frame. Keys correspond to bits
through their labels and indices, so that the key labelled ‘0’
correspond to bit 0 (the least significant bit), and the key
labelled ‘b’ correspond to bit 11 (obviously).</li>
<li>down() returns a bit vector indicating which keys were down
during the previous frame. The same correspondence applies.</li>
<li>send(b, n) sends n words from buffer b though the
speaker.</li>
<li>recv(b, n) receives up to n words into buffer b through the
microphone. It return the actual number of words received.</li>
<li>rand(n) returns a random number in the range [0, n)</li>
<li>next(dt) sleeps until the next frame, dt cs (centiseconds)
after the start of the current frame, returning immediately if
that moment has already passed.</li>
</ol>
</div>

<div class="column">
<h1>BadgeScript (BS)</h1>
<h2>Overview</h2>
<p>BS is a state-of-the-art structured high-level
programming language.</p>

<h2>Lexical structure</h2>
<p>[TBD]</p>

<h2>Syntactic structure</h2>
<code><span class="meta">{</span>foo<span class="meta">} = (</span>foo<span class="meta">(</span>, foo<span class="meta">)*)?</span></code>
<div class="display">
<pre>
prog  <span class="meta">←</span> block
block <span class="meta">←</span> dec<span class="meta">*</span> state<span class="meta">*</span>
dec   <span class="meta">←</span> byte id <span class="meta">{</span>num <span class="meta">|</span> str<span class="meta">}</span> end
      <span class="meta">|</span> word id <span class="meta">{</span>num<span class="meta">}</span> end
      <span class="meta">|</span> var id
      <span class="meta">|</span> arr id[<span class="meta">{</span>exp<span class="meta">}</span>]
      <span class="meta">|</span> proc id(<span class="meta">{</span>exp<span class="meta">}</span>) block end
      <span class="meta">|</span> fun id←id(<span class="meta">{</span>exp<span class="meta">}</span>) block end
state <span class="meta">←</span> id←exp
      <span class="meta">|</span> id<span class="meta">(</span>[<span class="meta">{</span>exp<span class="meta">}</span>]<span class="meta">)?</span>←exp
      <span class="meta">|</span> id(<span class="meta">{</span>exp<span class="meta">}</span>)
      <span class="meta">|</span> if exp block <span class="meta">(</span>elif exp block<span class="meta">)*</span>
        <span class="meta">(</span>else block<span class="meta">)?</span> end
      <span class="meta">|</span> while exp block end
      <span class="meta">|</span> for id exp block end
      <span class="meta">|</span> break
      <span class="meta">|</span> cont
      <span class="meta">|</span> ret
exp   <span class="meta">←</span> num
      <span class="meta">|</span> id
      <span class="meta">|</span> op exp
      <span class="meta">|</span> exp op exp
      <span class="meta">|</span> id[<span class="meta">{</span>exp<span class="meta">}</span>]
      <span class="meta">|</span> id(<span class="meta">{</span>exp<span class="meta">}</span>)
</pre>
</div>
<p>Operators in BS use some fancy characters, because a
programming language doesn’t <em>have</em> to be ugly.</p>
<div class="display">
<div id="operator-table">
<div><code>-a</code></div>
<div>Minus <code>a</code></div>
<div><code>~a</code></div>
<div>Not <code>a</code></div>
<div><code>a+b</code></div>
<div><code>a</code> plus <code>b</code></div>
<div><code>a-b</code></div>
<div><code>a</code> minus <code>b</code></div>
<div><code>a×b</code></div>
<div><code>a</code> times <code>b</code></div>
<div><code>a÷b</code></div>
<div>The quotient when <code>a</code> is divided by <code>b</code></div>
<div><code>b|a</code></div>
<div>The remainder when <code>a</code> is divided by <code>b</code></div>
<div><code>a&amp;b</code></div>
<div><code>a</code> and <code>b</code></div>
<div><code>a∨b</code></div>
<div><code>a</code> or <code>b</code></div>
<div><code>a~b</code></div>
<div><code>a</code> exclusive or <code>b</code></div>
<div><code>a«b</code></div>
<div><code>a</code> shifted left <code>b</code> bits</div>
<div><code>a»b</code></div>
<div><code>a</code> shifted right <code>b</code> bits</div>
<div><code>a&lt;b</code></div>
<div><code>a</code> less than <code>b</code></div>
<div><code>a≤b</code></div>
<div><code>a</code> less than or equal to <code>b</code></div>
<div><code>a=b</code></div>
<div><code>a</code> equal to <code>b</code></div>
<div><code>a≥b</code></div>
<div><code>a</code> greater than or equal to <code>b</code></div>
<div><code>a&gt;b</code></div>
<div><code>a</code> greater than <code>b</code></div>
<div><code>a≠b</code></div>
<div><code>a</code> not equal to <code>b</code></div>
</div>
</div>
<ul>
<li>Exclusive or is denoted by <code>~</code> because fuck it,
there is no good established notation for it, and it relates to
not through <code>~a=1~a</code> in a similar fashion at to how
subtraction relates to negation through <code>-a=0-a</code>,
but this connection is strenuous at best.</li>
</ul>
<p>
<code>[+-×÷&amp;∨«»]</code> are left associative,
<code>[×÷]</code> binds tighter than <code>[+-]</code> binds
tighter than <code>[&lt;≤=≥&gt;≠]</code> and <code>[&amp;]</code>
binds tighter than <code>[∨]</code>.
</p>
<p>
Variables and arrays are allocated on the stack, while data and
subroutines are allocated in the cart. The way to create a
persistent (cart allocated) variable is to use a data
declaration.
</p>
<p>
Variable as passed by value and arrays are passed by reference.
If you need a pass-by-reference variable, you may use a 0-rank
array (<code>arr a[]</code>).
</p>
</div>

<div class="column">
<h1>Badge Integrated Develpment Environment (BadIDE)</h2>
<p>BadIDE consists of three parts: an editor, a compiler and a
simulator, where the simulator in turn consists of a virtual
machine, a display, a keypad, and two monitors, one for the cart
and one for the memory.</p>
</div>
</div>
</body>
</html>
